import sys
import os
from pathlib import Path

# --- Path Setup (Auto-generated by migration) ---
# Define Project Root (Assuming this file is in tests/)
PROJECT_ROOT = Path(__file__).resolve().parents[1]

# Add 'api' to sys.path to allow 'from app...' imports
if str(PROJECT_ROOT / "api") not in sys.path:
    sys.path.append(str(PROJECT_ROOT / "api"))

# Add Project Root to sys.path to allow 'from dashboard...' or other root imports
if str(PROJECT_ROOT) not in sys.path:
    sys.path.append(str(PROJECT_ROOT))
# ------------------------------------------------
# pip install python-dotenv google-generativeai openai

import time
from statistics import mean

import google.generativeai as genai
from openai import OpenAI
from dotenv import load_dotenv
import os


PROMPT = """당신은 전문 교정 전문가입니다. 아래 지침에 따라 문장을 교정해 주세요.
**교정 분야**: general
- 일반적인 문장 스타일로, 명확하고 자연스럽게 교정하세요.
**교정 강도**: weak
- 문장의 흐름과 명확성을 개선하세요. 어색한 표현을 자연스럽게 다듬고, 가독성을 높이세요.
**언어**: 한국어로 작성
**추가 요청**: 없음
**문맥 정보**:
- 이전 문장: 없음
- 다음 문장: 없음
**중요 규칙**:
1. 반드시 교정된 문장 3개만 생성하세요
2. 각 문장은 줄바꿈으로만 구분합니다
3. 번호, 불릿, 설명문, 서문 등은 일절 포함하지 마세요
4. 각 버전은 서로 다른 접근 방식이나 뉘앙스를 가져야 합니다
5. 원문의 핵심 의미는 반드시 유지하세요
---
**원본 문장**: 예시 문장입니다. 품질 비교 테스트용으로 작성되었습니다.
---
교정된 문장 3개:"""


def clean_text(text: str) -> str:
    """
    불필요한 공백과 빈 줄을 제거하여 텍스트를 정리합니다.
    (OpenAI의 불필요한 들여쓰기나 이중 줄바꿈 해결)
    """
    if not text:
        return ""
    # 1. 각 줄의 앞뒤 공백 제거
    # 2. 빈 줄은 제외하고 다시 합침
    lines = [line.strip() for line in text.splitlines() if line.strip()]
    return "\n".join(lines)


def measure_gemini(prompt: str, iterations: int = 1):
    """Gemini 응답 시간 + 응답 내용 반환"""
    gemini_times = []
    responses = []
    # Gemini 모델 설정
    model = genai.GenerativeModel("models/gemini-2.5-flash") 
    # (참고: gemini-2.5-flash는 아직 공개 전일 수 있어 2.0 또는 1.5로 확인 필요, 
    #  코드상의 모델명은 사용자 환경에 맞게 유지했습니다)

    for _ in range(iterations):
        start = time.perf_counter()
        response = model.generate_content(prompt)
        text = response.text
        elapsed = time.perf_counter() - start

        gemini_times.append(elapsed)
        responses.append(clean_text(text)) # 텍스트 정리 적용

    return mean(gemini_times), responses


def measure_openai(prompt: str, iterations: int = 1):
    """OpenAI 응답 시간 + 응답 내용 반환"""
    client = OpenAI()
    openai_times = []
    responses = []

    for _ in range(iterations):
        start = time.perf_counter()
        # 사용자의 환경에 맞춘 메서드 유지 (client.responses.create)
        # 일반적인 Chat Completion은 client.chat.completions.create 입니다.
        response = client.responses.create(
            model="gpt-4.1-nano",
            input=prompt,
        )
        # 응답 객체 구조에 따라 .output_text가 맞는지 확인 필요
        text = response.output_text
        elapsed = time.perf_counter() - start

        openai_times.append(elapsed)
        responses.append(clean_text(text)) # 텍스트 정리 적용

    return mean(openai_times), responses


def main():
    load_dotenv()
    genai.configure(api_key=os.getenv("GEMINI_API_KEY"))
    os.environ["OPENAI_API_KEY"] = os.getenv("OPENAI_API_KEY", "")

    print("Gemini 테스트 중...")
    gemini_avg, gemini_responses = measure_gemini(PROMPT)

    print("OpenAI 테스트 중...")
    openai_avg, openai_responses = measure_openai(PROMPT)

    print("\n===== 결과 비교 =====")
    print(f"Gemini 평균 응답 시간: {gemini_avg:.3f} 초")
    print(f"OpenAI 평균 응답 시간: {openai_avg:.3f} 초")

    print("\n===== Gemini 응답 =====")
    for i, resp in enumerate(gemini_responses):
        print(f"\n--- Gemini 응답 #{i+1} ---\n{resp}")

    print("\n===== OpenAI 응답 =====")
    for i, resp in enumerate(openai_responses):
        print(f"\n--- OpenAI 응답 #{i+1} ---\n{resp}")


if __name__ == "__main__":
    main()
