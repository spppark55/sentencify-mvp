from __future__ import annotations
import sys
import os
from pathlib import Path

# --- Path Setup (Auto-generated by migration) ---
# Define Project Root (Assuming this file is in tests/)
PROJECT_ROOT = Path(__file__).resolve().parents[1]

# Add 'api' to sys.path to allow 'from app...' imports
if str(PROJECT_ROOT / "api") not in sys.path:
    sys.path.append(str(PROJECT_ROOT / "api"))

# Add Project Root to sys.path to allow 'from dashboard...' or other root imports
if str(PROJECT_ROOT) not in sys.path:
    sys.path.append(str(PROJECT_ROOT))
# ------------------------------------------------
#!/usr/bin/env python
"""
Phase 2 Integration Test – Step 5: Dashboard Queries

This script verifies that the dashboard queries in `dashboard/queries.py`
can correctly connect to MongoDB, aggregate the log data, and return
expected values for the Correction Funnel and other metrics.

It follows the TDD principle by being created before the implementation.
This test will fail until the queries are correctly implemented.

Prerequisites:
- MongoDB running and accessible at MONGO_URI.
- `pip install pymongo requests`
"""

import os
import sys
from datetime import datetime, timedelta

import pymongo

# Ensure the app path is in the sys.path to allow for package imports
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from dashboard.queries import (
    get_correction_funnel_data,
    get_user_profile_coverage,
    get_db,
)

# --- Test Configuration ---
MONGO_URI = os.getenv("MONGO_URI", "mongodb://localhost:27017/")
DB_NAME = os.getenv("MONGO_DB_NAME", "sentencify")

# Collections to be used for the test
# These names should align with the collections used by the consumer
LOG_A_COLLECTION = "log_a_recommend"
LOG_B_COLLECTION = "log_b_run"
LOG_C_COLLECTION = "log_c_select"
USERS_COLLECTION = "users"


def print_step(title: str):
    """Prints a formatted step title."""
    print("\n" + "=" * 80)
    print(f"  {title}")
    print("=" * 80)


def setup_test_data():
    """
    Injects a controlled set of mock data into MongoDB for funnel testing.
    - 10 "View A" events
    - 5 of which lead to a "Run B" event
    - 2 of which lead to an "Accept C" event
    """
    print_step("SETUP: Injecting mock data into MongoDB")
    db = get_db(MONGO_URI, DB_NAME)

    # Clean up previous test data
    db[LOG_A_COLLECTION].delete_many({"user_id": "dashboard_tester"})
    db[LOG_B_COLLECTION].delete_many({"user_id": "dashboard_tester"})
    db[LOG_C_COLLECTION].delete_many({"user_id": "dashboard_tester"})
    db[USERS_COLLECTION].delete_many({"email": {"$regex": "tester"}})
    print("Cleaned up previous mock data.")

    # --- Inject Data ---
    recommend_session_ids = [f"session_{i}" for i in range(10)]
    now = datetime.utcnow()

    # 10 Log A events (Views)
    log_a_docs = [
        {
            "recommend_session_id": sid,
            "user_id": "dashboard_tester",
            "event": "editor_recommend_options",
            "time": int((now - timedelta(minutes=i)).timestamp()),
        }
        for i, sid in enumerate(recommend_session_ids)
    ]
    db[LOG_A_COLLECTION].insert_many(log_a_docs)
    print(f"Inserted {len(log_a_docs)} Log A (View) documents.")

    # 5 Log B events (Runs) linked to the first 5 sessions
    log_b_docs = [
        {
            "recommend_session_id": sid,
            "user_id": "dashboard_tester",
            "event": "editor_run_paraphrasing",
            "time": int((now - timedelta(minutes=i)).timestamp()),
        }
        for i, sid in enumerate(recommend_session_ids[:5])
    ]
    db[LOG_B_COLLECTION].insert_many(log_b_docs)
    print(f"Inserted {len(log_b_docs)} Log B (Run) documents.")

    # 2 Log C events (Accepts) linked to the first 2 sessions
    log_c_docs = [
        {
            "recommend_session_id": sid,
            "user_id": "dashboard_tester",
            "event": "editor_selected_paraphrasing",
            "was_accepted": True,
            "time": int((now - timedelta(minutes=i)).timestamp()),
        }
        for i, sid in enumerate(recommend_session_ids[:2])
    ]
    # Add one "rejected" event to ensure it's not counted
    log_c_docs.append(
        {
            "recommend_session_id": recommend_session_ids[2],
            "user_id": "dashboard_tester",
            "event": "editor_selected_paraphrasing",
            "was_accepted": False,
            "time": int((now - timedelta(minutes=2)).timestamp()),
        }
    )
    db[LOG_C_COLLECTION].insert_many(log_c_docs)
    print(f"Inserted {len(log_c_docs)} Log C (Select) documents (including one rejection).")

    # User data for coverage test
    # Assume some users have profiles and some do not
    user_docs = [
        {"email": "tester1@test.com", "profile": {"has_embedding": True}},
        {"email": "tester2@test.com", "profile": {"has_embedding": False}},
        {"email": "tester3@test.com", "profile": None},
        {"email": "tester4@test.com"}, # no profile field
    ]
    db[USERS_COLLECTION].insert_many(user_docs)
    print(f"Inserted {len(user_docs)} user documents for coverage test.")


def main():
    """Main test execution function."""
    try:
        setup_test_data()

        # --- Test 1: Correction Funnel Query ---
        print_step("TEST 1: get_correction_funnel_data()")
        
        funnel_data = get_correction_funnel_data(user_id="dashboard_tester")
        print(f"Query Result: {funnel_data}")

        assert funnel_data is not None, "Funnel data should not be None"
        assert isinstance(funnel_data, dict), "Funnel data should be a dictionary"
        
        expected_keys = ["views_a", "runs_b", "accepts_c"]
        for key in expected_keys:
            assert key in funnel_data, f"Result missing expected key: {key}"

        # Assert based on the injected data
        assert funnel_data["views_a"] == 10, f"Expected 10 views (A), but got {funnel_data['views_a']}"
        assert funnel_data["runs_b"] == 5, f"Expected 5 runs (B), but got {funnel_data['runs_b']}"
        assert funnel_data["accepts_c"] == 2, f"Expected 2 accepts (C), but got {funnel_data['accepts_c']}"
        print("✅ PASSED: Funnel data counts are correct.")

        # --- Test 2: User Profile Coverage Query ---
        print_step("TEST 2: get_user_profile_coverage()")

        user_filter = {"email": {"$regex": "tester"}}
        coverage = get_user_profile_coverage(user_filter=user_filter)
        print(f"Query Result: {coverage}")

        assert coverage is not None, "Coverage data should not be None"
        assert isinstance(coverage, float), "Coverage should be a float"
        assert 0.0 <= coverage <= 1.0, f"Coverage must be between 0 and 1, but got {coverage}"
        
        # Expected: 1 user out of 4 has a profile with an embedding
        expected_coverage = 1 / 4
        assert abs(coverage - expected_coverage) < 0.001, \
            f"Expected coverage of {expected_coverage}, but got {coverage}"
        print(f"✅ PASSED: User profile coverage is correct ({coverage:.2f}).")


    except Exception as e:
        print(f"\n❌ TEST FAILED: An unexpected error occurred: {e}")
        import traceback
        traceback.print_exc()
        sys.exit(1)
        
    print("\n🎉🎉🎉 ALL DASHBOARD INTEGRATION TESTS PASSED! 🎉🎉🎉")


if __name__ == "__main__":
    main()

